<div x-data="tagInput" class="relative">
    <!-- Hidden input for form submission -->
    <input type="hidden" name="{{ widget.name }}" x-ref="hiddenInput" value="{{ widget.value|default:'' }}">
    
    <!-- Tag display and input area -->
    <div class="relative flex flex-wrap gap-2 p-2 bg-base-100 rounded-xl border border-base-300 focus-within:border-primary focus-within:ring-1 focus-within:ring-primary">
        <!-- Existing tags -->
        <template x-for="(tag, index) in tags" :key="index">
            <span class="inline-flex items-center gap-1 px-2 py-1 bg-primary/10 text-primary rounded-lg text-sm">
                <span x-text="tag"></span>
                <button type="button" @click="removeTag(index)" class="hover:text-error">
                    <iconify-icon icon="octicon:x-16"></iconify-icon>
                </button>
            </span>
        </template>
        
        <!-- Input field -->
        <div class="flex-1 min-w-[8rem]">
            <input type="text"
                x-model="input"
                @keydown.enter.prevent="addTag(input)"
                @keydown.backspace="input === '' && tags.length > 0 ? removeTag(tags.length - 1) : null"
                @keydown.down.prevent="navigateSuggestion(1)"
                @keydown.up.prevent="navigateSuggestion(-1)"
                @keydown.escape="closeSuggestions()"
                :placeholder="tags.length === 0 ? 'Start typing to add skills...' : ''"
                class="w-full border-0 p-0.5 bg-transparent focus:ring-0 text-sm placeholder:text-base-content/50">
        </div>
    </div>

    <!-- Suggestions dropdown -->
    <div x-show="suggestions.length > 0"
         x-transition:enter="transition ease-out duration-200"
         x-transition:enter-start="opacity-0 scale-95"
         x-transition:enter-end="opacity-100 scale-100"
         x-transition:leave="transition ease-in duration-150"
         x-transition:leave-start="opacity-100 scale-100"
         x-transition:leave-end="opacity-0 scale-95"
         @click.away="closeSuggestions()"
         class="absolute z-50 w-full mt-1 bg-base-100 rounded-lg shadow-lg border border-base-300 max-h-48 overflow-y-auto custom-scrollbar">
        
        <!-- Loading state -->
        <div x-show="loading" class="p-2 text-center">
            <span class="loading loading-spinner loading-sm"></span>
        </div>

        <!-- Suggestions list -->
        <template x-if="!loading">
            <div class="p-1">
                <template x-for="(suggestion, index) in suggestions" :key="index">
                    <button type="button"
                            @click="addTag(suggestion)"
                            class="w-full text-left px-3 py-2 rounded-lg text-sm hover:bg-base-200 flex items-center gap-2"
                            :class="{ 'bg-base-200': selectedIndex === index }">
                        <iconify-icon :icon="suggestion.icon || 'octicon:code-16'"></iconify-icon>
                        <span x-text="suggestion.label || suggestion"></span>
                    </button>
                </template>
            </div>
        </template>
    </div>
</div>

<script>
document.addEventListener('alpine:init', () => {
    Alpine.data('tagInput', () => ({
        tags: [],
        input: '',
        suggestions: [],
        loading: false,
        selectedIndex: -1,

        init() {
            // Initialize with existing tags if any
            const existingTags = this.$refs.hiddenInput.value;
            if (existingTags) {
                this.tags = existingTags.split(',').map(t => t.trim()).filter(t => t);
            }
        },

        async fetchSuggestions() {
            if (this.input.length < 2) {
                this.suggestions = [];
                return;
            }

            this.loading = true;
            try {
                const response = await fetch(`/jobs/skills-autocomplete/?q=${encodeURIComponent(this.input)}`);
                const data = await response.json();
                this.suggestions = data.results || [];
                this.selectedIndex = -1;
            } catch (error) {
                console.error('Error fetching suggestions:', error);
                this.suggestions = [];
            } finally {
                this.loading = false;
            }
        },

        addTag(value) {
            const tag = typeof value === 'object' ? value.label : value;
            if (tag && !this.tags.includes(tag)) {
                this.tags.push(tag);
                this.updateHiddenInput();
            }
            this.input = '';
            this.suggestions = [];
            this.selectedIndex = -1;
        },

        removeTag(index) {
            this.tags.splice(index, 1);
            this.updateHiddenInput();
        },

        updateHiddenInput() {
            this.$refs.hiddenInput.value = this.tags.join(',');
        },

        navigateSuggestion(direction) {
            if (this.suggestions.length === 0) return;
            
            this.selectedIndex = 
                (this.selectedIndex + direction + this.suggestions.length) % this.suggestions.length;
            
            // Ensure the selected item is visible
            const elements = document.querySelectorAll('[x-data="tagInput"] button');
            if (elements[this.selectedIndex]) {
                elements[this.selectedIndex].scrollIntoView({
                    block: 'nearest',
                    behavior: 'smooth'
                });
            }
        },

        closeSuggestions() {
            this.suggestions = [];
            this.selectedIndex = -1;
        }
    }));
});
</script>
